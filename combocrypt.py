import os
import base64
import json

from Crypto.Cipher import AES
from Crypto.Cipher import PKCS1_OAEP
from Crypto.PublicKey import RSA

# RSA start

# RSA encrypt a byte array by encoding it with base64 first
def _rsa_encrypt_bytes(public_key, bytes):
	encoded = base64.b64encode(bytes)
	cipher = PKCS1_OAEP.new(public_key)
	return cipher.encrypt(encoded)

# RSA decrypt bytes that correspond to a base64 encoded string generated by rsa_encrypt_bytes(), back to the original bytes
def _rsa_decrypt_bytes(private_key, bytes):
	cipher = PKCS1_OAEP.new(private_key)
	encoded = cipher.decrypt(bytes)
	return base64.b64decode(encoded)

# RSA end

# AES start

def _aes_random_key(keysize):
	bytes = keysize // 8 # bytes are 8 bits
	return os.urandom(bytes)

def _pad_bytes(data):
	padded = data[:]
	length = AES.block_size - (len(data) % AES.block_size)
	padded += bytes([length]) * length
	return padded

def _unpad_bytes(data):
	unpadded = data[:-data[-1]]
	return unpadded

def _aes_encrypt_bytes(key, bytes):
	padded = _pad_bytes(bytes)
	iv = os.urandom(AES.block_size)
	cipher = AES.new(key, AES.MODE_CBC, iv)
	return (iv + cipher.encrypt(padded))

def _aes_decrypt_bytes(key, bytes):
	encrypted = bytes[:]
	iv = encrypted[:AES.block_size]
	cipher = AES.new(key, AES.MODE_CBC, iv)
	decrypted = cipher.decrypt(encrypted[AES.block_size:])
	return _unpad_bytes(decrypted)

# AES end

class ComboCrypt:

	AES_KEYSIZE = None
	RSA_KEYSIZE = None

	def __init__(self, aes_keysize=256, rsa_keysize=4096):
		self.AES_KEYSIZE = aes_keysize
		self.RSA_KEYSIZE = rsa_keysize

	def rsa_random_keypair(self):
		keypair = RSA.generate(self.RSA_KEYSIZE, os.urandom)
		return keypair

	def save_rsa_key(key, file):
		with open(file, "wb") as writer:
			bytes = key.exportKey("DER")
			encoded = base64.b64encode(bytes)
			writer.write(encoded)

	def load_rsa_key(file):
		key = None
		with open(file, "rb") as reader:
			encoded = reader.read()
			decoded = base64.b64decode(encoded)
			key = RSA.importKey(decoded)
		return key

	def combo_encrypt_file(self, file, public_key):
		data = None
		with open(file, "rb") as reader:
			data = reader.read()

		return self.combo_encrypt_data(data, public_key)

	def combo_decrypt_file(self, file, private_key):
		data = None
		with open(file, "r") as reader:
			data = reader.read()

		return self.combo_decrypt_data(data, private_key)

	def combo_encrypt_data(self, data, public_key):
		aes_key = _aes_random_key(self.AES_KEYSIZE) # generate a random 256-bit AES key
		aes_encrypted_data = _aes_encrypt_bytes(aes_key, data) # encrypt the data with the random AES key

		rsa_encrypted_aes_key = _rsa_encrypt_bytes(public_key, aes_key) # encrypt the AES key with the public key

		result = {} # create an empty dictionary
		result["RSAEncryptedAESKey"] = base64.b64encode(rsa_encrypted_aes_key).decode("ascii") # base64 encode the RSA-encrypted AES key for export
		result["AESEncryptedData"] = base64.b64encode(aes_encrypted_data).decode("ascii") # base64 encode the AES-encrypted data for export

		result_json = json.dumps(result) # serialize result as a JSON string
		return result_json # return the JSON string containing all the neccesary parts for the private key holder to decrypt the message

	def combo_decrypt_data(self, data_json, private_key):
		data = json.loads(data_json) # deserialize the JSON string to a dictionary

		rsa_encrypted_aes_key = base64.b64decode(data["RSAEncryptedAESKey"]) # decode the base64 RSA-encrypted AES key
		aes_encrypted_data = base64.b64decode(data["AESEncryptedData"]) # decide the AES-encrypted data

		aes_key = _rsa_decrypt_bytes(private_key, rsa_encrypted_aes_key) # decrypt the AES key with our private key

		decrypted = _aes_decrypt_bytes(aes_key, aes_encrypted_data) # decrypt the data with the newly-decrypted AES key
		return decrypted # return the decrypted data
