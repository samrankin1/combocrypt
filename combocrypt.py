import os
import base64
import json

from Crypto.Cipher import AES
from Crypto.Cipher import PKCS1_OAEP
from Crypto.PublicKey import RSA

AES_KEYSIZE = 256
RSA_KEYSIZE = 4096

# RSA start

def rsa_random_keypair():
	"""Generate a random RSA keypair of the default size"""
	return RSA.generate(RSA_KEYSIZE, os.urandom)

def save_rsa_key(key, file):
	"""Save a RSA key to the given file"""
	with open(file, "w") as writer: # open the file for writing as text
		key_bytes = key.exportKey("DER") # export the key to a bytes object
		encoded = base64.b64encode(key_bytes).decode("ascii") # encode the bytes with base64
		writer.write(encoded) # write the base64 string to the given file

def load_rsa_key(file):
	"""Load a RSA key from a file created by save_rsa_key"""
	key = None # this variable will hold the key once it is loaded
	with open(file, "r") as reader: # open the file for reading as text
		encoded = reader.read() # read the entire base64-encoded string from the file
		decoded = base64.b64decode(encoded) # decode the bytes object
		key = RSA.importKey(decoded) # import the key
	return key

def _rsa_encrypt_bytes(public_key, bytes):
	"""RSA encrypt a byte array by encoding it with base64 first"""
	encoded = base64.b64encode(bytes) # encode the data with base64
	cipher = PKCS1_OAEP.new(public_key) # create a new RSA cipher with the public key
	return cipher.encrypt(encoded) # encrypt the data with the cipher

def _rsa_decrypt_bytes(private_key, bytes):
	"""RSA decrypt bytes that correspond to a base64 encoded string generated by rsa_encrypt_bytes(), back to the original bytes"""
	cipher = PKCS1_OAEP.new(private_key) # create a new RSA cipher with the private key
	encoded = cipher.decrypt(bytes) # decrypt the bytes to get a base64 string
	return base64.b64decode(encoded) # decode the base64 string to get the original bytes

# RSA end

# AES start

def _aes_random_key(keysize):
	"""Generate a random AES key of the given size"""
	bytes = keysize // 8 # bytes are 8 bits
	return os.urandom(bytes) # the key consists of cryptographically secure random bytes

def _pad_bytes(data):
	"""Pad bytes of data for encryption by a CBC-mode AES cipher"""
	length = AES.block_size - (len(data) % AES.block_size) # get the number of bytes needed to round out the data's length to a mutiple of the block size
	return data + (bytes([length]) * length) # add the byte 'n', 'n' times to the end of the array

def _unpad_bytes(data):
	"""Unpad bytes of data that were padded by _pad_bytes"""
	unpadded = data[:-data[-1]] # remove the last 'n' bytes, as indicated by the last byte in the list
	return unpadded

def _aes_encrypt_bytes(data, key):
	"""Encrypt some data with the given AES key"""
	padded = _pad_bytes(data) # pad the data
	iv = os.urandom(AES.block_size) # generate an initialization vector consisting of 16 random bytes (one block length)
	cipher = AES.new(key, AES.MODE_CBC, iv) # create a new CBC-mode cipher with the given key and IV
	return (iv + cipher.encrypt(padded)) # return the encrypted bytes, with the IV at the beginning of the list

def _aes_decrypt_bytes(data, key):
	"""Decrypt data that was encrypted by _aes_encrypt_bytes"""
	iv = data[:AES.block_size] # the IV is the first 16 bytes of the encrypted data
	cipher = AES.new(key, AES.MODE_CBC, iv) # create a new CBC-mode cipher with the given key and IV
	decrypted = cipher.decrypt(data[AES.block_size:]) # decrypt the data, which comes after the IV
	return _unpad_bytes(decrypted) # unpad the bytes before returning

# AES end

def combo_encrypt_data(data, public_key):
	"""Encrypt data using the ComboCrypt scheme, with the given public key as a recipient"""
	aes_key = _aes_random_key(AES_KEYSIZE) # generate a random 256-bit AES key
	aes_encrypted_data = _aes_encrypt_bytes(data, aes_key) # encrypt the data with the random AES key

	rsa_encrypted_aes_key = _rsa_encrypt_bytes(public_key, aes_key) # encrypt the AES key with the public key

	return rsa_encrypted_aes_key, aes_encrypted_data

def combo_decrypt_data(rsa_encrypted_aes_key, aes_encrypted_data, private_key):
	"""Decrypt data that was encrypted by combo_encrypt_data"""
	aes_key = _rsa_decrypt_bytes(private_key, rsa_encrypted_aes_key) # decrypt the AES key with our private key
	decrypted = _aes_decrypt_bytes(aes_encrypted_data, aes_key) # decrypt the data with the newly-decrypted AES key

	return decrypted # return the decrypted data

def combo_encrypt_json(data, public_key):
	"""Encrypt data using the ComboCrypt scheme with the given public key, returning the result serialized as a JSON array"""
	rsa_encrypted_aes_key, aes_encrypted_data = combo_encrypt_data(data, public_key)

	result = {} # create an empty dictionary
	result["RSAEncryptedAESKey"] = base64.b64encode(rsa_encrypted_aes_key).decode("ascii") # base64 encode the RSA-encrypted AES key for export
	result["AESEncryptedData"] = base64.b64encode(aes_encrypted_data).decode("ascii") # base64 encode the AES-encrypted data for export

	return json.dumps(result) # return the JSON string containing all the neccesary parts for the private key holder to decrypt the message

def combo_decrypt_json(data_json, private_key):
	"""Decrypt data from a JSON array that was created by combo_encrypt_json"""
	data = json.loads(data_json) # deserialize the JSON string to a dictionary

	rsa_encrypted_aes_key = base64.b64decode(data["RSAEncryptedAESKey"]) # decode the base64 RSA-encrypted AES key
	aes_encrypted_data = base64.b64decode(data["AESEncryptedData"]) # decide the AES-encrypted data

	return combo_decrypt_data(rsa_encrypted_aes_key, aes_encrypted_data, private_key)

def combo_encrypt_file_json(file, public_key):
	"""Encrypt data from the given file using the ComboCrypt scheme with the given public key, and serialize the result as JSON"""
	data = None # this will store the data once it is read from the file
	with open(file, "rb") as reader: # open the file for reading as binary
		data = reader.read() # read the entire contents of the file

	return combo_encrypt_json(data, public_key) # encrypt the data and serialize the result as a JSON array

def combo_decrypt_file_json(file, private_key):
	"""Decrypt data from a file that contains a JSON array that was created by combo_encrypt_json"""
	data_json = None # this will store the JSON string once it is read from the file
	with open(file, "r") as reader: # open the file for reading as text
		data_json = reader.read() # read the entire contents of the file

	return combo_decrypt_json(data_json, private_key) # deserialize and decrypt the JSON



